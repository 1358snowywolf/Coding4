#include <bits/stdc++.h>

using namespace std;
map<int, vector<pair<int, int>>> graph;
vector<bool> visited;
vector<int> parents;
long long total = 0;
long long MST_cost = 0;

//int findParents(int u){
//	while(parents[u] != u){
//		u = parents[u];
//	}
//
//	return u;
//}
//
//void connect(int u, int v){
//	int x = findParents(u);
//	int y = findParents(v);
//
//	parents[y] = x;
//}
//
//void KrushalAlgorithm(vector<tuple<int, int, int>> edges){
//	for(tuple<int, int, int> edge : edges){
//		int weight, u, v;
//		tie(weight, u, v) = edge;
//
//		if(findParents(u) != findParents(v)){
//			connect(u, v);
//			total += weight;
//		}
//	}
//}

void process(int u, priority_queue<pair<int, int>>& pq){
	visited[u] = true;

	for(pair<int, int> n : graph[u]){
		if(!visited[n.first]){
			pq.push(make_pair(n.second * -1, n.first));
		}
	}
}

void Prim(){
	priority_queue<pair<int, int>> pq;
	process(0, pq);

	while(!pq.empty()){
		pair<int, int> u = pq.top();
		pq.pop();

		if(!visited[u.second]){
			MST_cost += (u.first * -1);
		}

		process(u.second, pq);
	}
}

int main() {
	int N;
	cin >> N;
	vector<int> ID;
	vector<tuple<int, int, int>> edges;

	for(int i = 0; i < N; i++){
		int input;
		cin >> input;
		ID.push_back(input);
		parents.push_back(i);
	}

	for(int i = 0; i < N; i++){
		for(int j = i + 1; j < N; j++){
			int XOR = ID[i] ^ ID[j];
			edges.push_back(make_tuple(XOR, i, j));
		}
	}

	sort(edges.rbegin(), edges.rend());
	KrushalAlgorithm(edges);

	cout << total << endl;

	return 0;
}
