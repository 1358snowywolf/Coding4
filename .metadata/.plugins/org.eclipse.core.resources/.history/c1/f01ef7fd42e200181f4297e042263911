#include <bits/stdc++.h>

using namespace std;

map<int, vector<pair<int, int>>> makeGraph(vector<vector<int>> elevators, vector<int> speed){
	map<int, vector<pair<int, int>>> graph;

	for(int i = 0; i < (int) elevators.size(); i++){
		graph.insert(make_pair((i * 100) + elevators[i][0], vector<pair<int, int>> ()));
		int previous = elevators[i][0];

		for(int j = 1; j < (int) elevators[i].size(); j++){
			int current = elevators[i][j] + (i * 100);
			graph[(i * 100) + previous].push_back(make_pair(current, (current - previous) * speed[i]));
			graph.insert(make_pair((i * 100) + elevators[i][j], vector<pair<int, int>> ()));

//			for(int k = i - 1; k >= 0; k++){
//				if(graph.find((k * 100) + elevators[i][j]) != graph.end()){
//					graph[(k * 100) + elevators[i][j]].push_back(make_pair(current, 60));
//				}
//			}

			previous = current;
		}
	}

	return graph;
}

vector<int> Dijkstra(map<int, vector<pair<int, int>>> graph, vector<vector<int>> elevators){
	priority_queue<pair<int, int>> pq;
	vector<int> distance (elevators.size() * 100, 1076000);

	for(int i = 0; i < (int) elevators.size(); i++){
		if(elevators[i][0] == 0){
			pq.push(make_pair(0, i * 100));
		}
	}

	distance[0] = 0;

	while(!pq.empty()){
		auto front = pq.top();
		pq.pop();

		if(front.first * -1 > distance[front.second]){
			continue;
		}

		for(auto n : graph[front.second]){
            if(distance[front.second] + n.second < distance[n.first]){
                distance[n.first] = distance[front.second] + n.second;
                pq.push({distance[n.first] * -1, n.first});
            }
		}
	}

	return distance;
}

int main() {
	int N, K;

	while(cin >> N){
		cin >> K;
		vector<vector<int>> elevators;
		vector<int> speed;

		for(int i = 0; i < N; i++){
			int s;
			cin >> s;
			speed.push_back(s);
		}

		cin.ignore();

		for(int i = 0; i < N; i++){
			int tmp;
			string line;
			getline(cin, line);
			istringstream iss(line);
			vector<int> input;

			while(iss >> tmp){
				input.push_back(tmp);
			}

			sort(input.begin(), input.end());
			elevators.push_back(input);
		}

		auto graph = makeGraph(elevators, speed);
		auto distance = Dijkstra(graph, elevators);

		for(auto i : graph){
			cout << i.first << ": ";

			for(auto j : i.second){
				cout << "(" << j.first << ", " << j.second << ") ";
			}

			cout << endl;
		}

		cout << K << endl;
	}

	return 0;
}
